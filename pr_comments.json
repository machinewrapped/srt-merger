[{"url":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/comments/2810915700","pull_request_review_id":3806929223,"id":2810915700,"node_id":"PRRC_kwDOK3wXas6niyt0","diff_hunk":"@@ -88,310 +91,11 @@\n     <script src=\"https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js\"></script>\n     <script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js\" integrity=\"sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL\" crossorigin=\"anonymous\"></script>\n \n-<script>\n-\n-async function compareFiles() {\n-    const formData = new FormData(document.getElementById('uploadForm'));\n-    const response = await fetch('/upload', {\n-        method: 'POST',\n-        body: formData\n-    });\n-    const data = await response.json();\n-\n-    populateTable(data.sections);\n-}\n-\n-function checkFilesSelected() {\n-    const file1 = document.querySelector('input[name=\"file1\"]').files[0];\n-    const file2 = document.querySelector('input[name=\"file2\"]').files[0];\n-\n-    if (file1 && file2) {\n-        compareFiles();\n-    }\n-}\n-\n-function formatTimestamp(milliseconds) {\n-    if (typeof milliseconds !== 'number') return milliseconds;\n-    \n-    const hours = Math.floor(milliseconds / 3600000);\n-    const minutes = Math.floor((milliseconds % 3600000) / 60000);\n-    const seconds = Math.floor((milliseconds % 60000) / 1000);\n-    const ms = milliseconds % 1000;\n-\n-    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;\n-}\n-\n-function replaceNewlinesWithBreaks(text) {\n-    return text.replace(/\\n/g, '<br/>');\n-}\n-\n-function generateSubtitleHTML(subtitles) {\n-    if (!subtitles || subtitles.length === 0) return '';\n-\n-    return subtitles.map(sub => `\n-        <div class='subtitle'>\n-            <b>${sub.index}. ${formatTimestamp(sub.start)} --> ${formatTimestamp(sub.end)}</b><br/>\n-            ${replaceNewlinesWithBreaks(sub.content)}\n-        </div>\n-    `).join('');\n-}\n-\n-function extractSubtitlesFromHtml(html) {\n-    const parser = new DOMParser();\n-    const doc = parser.parseFromString(html, 'text/html');\n-    const subtitles = doc.querySelectorAll('.subtitle');\n-\n-    return Array.from(subtitles).map((subtitle, n) => {\n-        const [header, ...textLines] = subtitle.innerHTML.split('<br>');\n-        header_text = header.replace(/<b>|<\\/b>/g, '').trim();\n-        const [index, timestamps] = header_text.split('. ');\n-        const [start, end] = timestamps.match(/\\d{2}:\\d{2}:\\d{2},\\d{3}/g);\n-\n-        return {\n-            index: parseInt(index.trim(), 10),\n-            start: start,\n-            end: end,\n-            content: textLines.join('')\n-        };\n-    });\n-}\n-\n-function extractSubtitlesFromText(text) {\n-    const lines = text.split('\\n\\n');\n-    return lines.map((line, n) => {\n-        const [header, ...textLines] = line.split('\\n');\n-        const [index, timestamps] = header.split('. ');\n-        const [start, end] = timestamps.split(' --> ');\n-\n-        return {\n-            index: parseInt(index.trim(), 10),\n-            start: start,\n-            end: end,\n-            content: textLines.join('\\n')\n-        };\n-    });\n-}\n-\n-function generateSubtitleText(subtitles) {\n-    if (!subtitles || subtitles.length === 0) return '';\n-\n-    lines = subtitles.map(sub => `${sub.index}\\n${sub.start} --> ${sub.end}\\n${sub.content.trim()}`)\n-    \n-    return lines.join('\\n\\n');\n-}\n-\n-function generateSubtitleContent(subtitles) {\n-    if (!subtitles || subtitles.length === 0) return '';\n-\n-    lines = subtitles.map(sub => `${sub.index}\\n${sub.start} --> ${sub.end}\\n${sub.content.trim()}`)\n-    \n-    return lines.join('\\n\\n');\n-}\n-\n-function isIdentical(file1, file2) {\n-    // If one is null and the other isn't, they're not identical\n-    if (!file1 || !file2) return false;\n-\n-    // If their lengths are different, they're not identical\n-    if (file1.length !== file2.length) return false;\n-\n-    // Compare each subtitle in the arrays\n-    for (let i = 0; i < file1.length; i++) {\n-        if (file1[i].start !== file2[i].start ||\n-            file1[i].end !== file2[i].end ||\n-            file1[i].content !== file2[i].content) {\n-            return false;\n-        }\n-    }\n-\n-    // If all checks passed, they're identical\n-    return true;\n-}\n-\n-function isIdenticalText(file1, file2) {\n-    // If one is null and the other isn't, they're not identical\n-    if (!file1 || !file2) return false;\n-    if (file1.length !== file2.length) return false;\n-\n-    for (let i = 0; i < file1.length; i++) {\n-        if (file1[i].content !== file2[i].content) {\n-            return false;\n-        }\n-    }\n-\n-    return true;\n-}\n+    <script src=\"js/srt-parser.js\"></script>\n+    <script src=\"js/app.js\"></script>\n \n-function createBootstrapCheckbox(name, value, isChecked = false, isHidden = false) {\n-    const checkboxWrapper = document.createElement('div');\n-    checkboxWrapper.classList.add('form-check');\n-\n-    const checkbox = document.createElement('input');\n-    checkbox.type = 'checkbox';\n-    checkbox.name = name;\n-    checkbox.value = value;\n-    checkbox.checked = isChecked;\n-    checkbox.classList.add('form-check-input');\n-    if (isHidden) checkbox.style.display = 'none';\n-\n-    checkbox.addEventListener('click', handleCheckboxClick);\n-\n-    checkboxWrapper.appendChild(checkbox);\n-\n-    return checkboxWrapper;\n-}\n-\n-function handleCheckboxClick(event) {\n-    const currentCheckbox = event.target;\n-    if (!event.shiftKey) {\n-        // Retrieve all checkboxes once to improve performance\n-        const siblingCheckboxes = document.querySelectorAll(\"input[type='checkbox']\");\n-        // Loop through checkboxes and deselect matching conditions\n-        siblingCheckboxes.forEach(checkbox => {\n-            if (checkbox !== currentCheckbox && checkbox.value === currentCheckbox.value) {\n-                checkbox.checked = false;\n-            }\n-        });\n-    }\n-}\n-\n-function autoResizeTextArea(textArea) {\n-    textArea.style.height = 'auto';\n-    console.log('Scroll height:', textArea.scrollHeight);\n-    textArea.style.height = textArea.scrollHeight + 'px';\n-}\n-\n-function makeEditable(cell, index, fileSide) {\n-    cell.ondblclick = () => {\n-        // Extract the content of the <div> with class 'subtitle' for the editable content\n-        const subtitles = extractSubtitlesFromHtml(cell.innerHTML);\n-        if (!subtitles) {\n-            console.error('Subtitle not found in cell:', cell);\n-            return;\n-        }\n-\n-        if (cell.querySelector('textarea')) {\n-            return;\n-        }\n-\n-        cell.dataset.file = fileSide;\n-        cell.dataset.index = index;\n-\n-        text = generateSubtitleText(subtitles)\n-        original = cell.innerHTML;\n-\n-        const input = document.createElement('textarea');\n-        input.value = text;\n-        input.classList.add('form-control');\n-        cell.innerHTML = '';\n-        cell.appendChild(input);\n-        autoResizeTextArea(input);\n-        input.addEventListener('input', () => autoResizeTextArea(input));\n-        input.focus();\n-\n-        input.onblur = () => {\n-            cell.innerHTML = original;\n-            updateSubtitlesOnServer(fileSide, index, input.value);\n-        };\n-    };\n-}\n-\n-function populateTable(results) {\n-    const tableBody = document.getElementById('comparisonTable').querySelector('tbody');\n-    tableBody.innerHTML = ''; // Clear existing rows\n-\n-    results.forEach((result, index) => {\n-        const row = tableBody.insertRow();\n-        row.dataset.index = index;\n-\n-        // File 1 column\n-        const cell1 = row.insertCell();\n-        cell1.innerHTML = generateSubtitleHTML(result.file1);\n-        cell1.classList.add('file-column', 'file1');\n-        makeEditable(cell1, index, 'file1')\n-\n-        // Checkbox for File 1\n-        const cellCheckbox1 = row.insertCell();\n-        const checkbox1 = createBootstrapCheckbox('file1', result.index, !!result.file1, !result.file1);\n-        cellCheckbox1.appendChild(checkbox1);\n-\n-        // Checkbox for File 2\n-        const cellCheckbox2 = row.insertCell();\n-        const checkbox2 = createBootstrapCheckbox('file2', result.index, false, !result.file2);\n-        cellCheckbox2.appendChild(checkbox2);\n-\n-        // File 2 column\n-        const cell2 = row.insertCell();\n-        cell2.innerHTML = generateSubtitleHTML(result.file2);\n-        cell2.classList.add('file-column');\n-        makeEditable(cell2, index, 'file2')\n-\n-        if (isIdentical(result.file1, result.file2)) {\n-            checkbox2.style.display = 'none';\n-            cell2.style.color = 'lightgrey';\n-        } else if (isIdenticalText(result.file1, result.file2)) {\n-            cell2.style.color = 'grey';\n-        }\n-    });\n-}\n-\n-function updateCellContent(file, index, subtitles) {\n-    if (!subtitles) return;\n-\n-    const rows = document.querySelectorAll('tr');\n-    const row = Array.from(rows).find(row => row.dataset.index == index);\n-    console.assert(row, 'Row not found:', index);\n-\n-    const cells = row.querySelectorAll('td');\n-    const cell = Array.from(cells).find(cell => cell.dataset.file === file);\n-    console.assert(cell, 'Cell not found:', file, index);\n-\n-    cell.innerHTML = generateSubtitleHTML(subtitles);\n-}\n-\n-function updateSubtitlesOnServer(file, index, content) {\n-    fetch('/update-subtitle', {\n-        method: 'POST',\n-        headers: {\n-            'Content-Type': 'application/json',\n-        },\n-        body: JSON.stringify({ file, index, content }),\n-    })\n-    .then(response => response.json())\n-    .then(data => {\n-        console.log('Subtitle updated:', data);\n-        updateCellContent(file, index, data.subtitles);\n-    })\n-    .catch(error => {\n-        console.error('Error updating subtitle:', error);\n-    });\n-}\n-\n-async function saveMergedFile() {\n-    const selectedFile1Indices = [...document.querySelectorAll('input[name=\"file1\"]:checked')].map(checkbox => parseInt(checkbox.value, 10));\n-    const selectedFile2Indices = [...document.querySelectorAll('input[name=\"file2\"]:checked')].map(checkbox => parseInt(checkbox.value, 10));\n-\n-    const response = await fetch('/merge', {\n-        method: 'POST',\n-        headers: {\n-            'Content-Type': 'application/json'\n-        },\n-        body: JSON.stringify({\n-            file1Indices: selectedFile1Indices,\n-            file2Indices: selectedFile2Indices\n-        })\n-    });\n+    </script>\n \n-    const data = await response.blob();\n-    const url = URL.createObjectURL(data);\n-    const a = document.createElement('a');\n-    a.style.display = 'none';\n-    a.href = url;\n-    a.download = 'merged.srt';\n-    document.body.appendChild(a);\n-    a.click();\n-    URL.revokeObjectURL(url);\n-}\n \n     </script>\n     ","path":"public/index.html","commit_id":"8e98df7e41015b803cd6d19e0063cbda2a7981ca","original_commit_id":"8e98df7e41015b803cd6d19e0063cbda2a7981ca","user":{"login":"gemini-code-assist[bot]","id":176961590,"node_id":"BOT_kgDOCow4Ng","avatar_url":"https://avatars.githubusercontent.com/in/956858?v=4","gravatar_id":"","url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D","html_url":"https://github.com/apps/gemini-code-assist","followers_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/followers","following_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/repos","events_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"![critical](https://www.gstatic.com/codereviewagent/critical.svg)\n\nThere are stray `</script>` tags in the HTML file. This is invalid HTML and can cause unpredictable behavior in browsers, such as preventing scripts from executing correctly or causing rendering issues. These tags should be removed.","created_at":"2026-02-16T06:48:54Z","updated_at":"2026-02-16T06:48:55Z","html_url":"https://github.com/machinewrapped/srt-merger/pull/3#discussion_r2810915700","pull_request_url":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/3","_links":{"self":{"href":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/comments/2810915700"},"html":{"href":"https://github.com/machinewrapped/srt-merger/pull/3#discussion_r2810915700"},"pull_request":{"href":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/3"}},"reactions":{"url":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/comments/2810915700/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":97,"original_start_line":97,"start_side":"RIGHT","line":101,"original_line":101,"side":"RIGHT","author_association":"NONE","original_position":336,"position":336,"subject_type":"line"},{"url":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/comments/2810915702","pull_request_review_id":3806929223,"id":2810915702,"node_id":"PRRC_kwDOK3wXas6niyt2","diff_hunk":"@@ -0,0 +1,524 @@\n+\n+let fileSections = null;\n+let file1Data = null; // { name, content }\n+let file2Data = null; // { name, content }\n+\n+// IndexedDB Setup\n+const dbName = \"SrtMergerDB\";\n+const storeName = \"session\";\n+\n+function openDB() {\n+    return new Promise((resolve, reject) => {\n+        const request = indexedDB.open(dbName, 1);\n+        request.onerror = (event) => reject(\"IndexedDB error: \" + event.target.error);\n+        request.onsuccess = (event) => resolve(event.target.result);\n+        request.onupgradeneeded = (event) => {\n+            const db = event.target.result;\n+            if (!db.objectStoreNames.contains(storeName)) {\n+                db.createObjectStore(storeName, { keyPath: \"id\" });\n+            }\n+        };\n+    });\n+}\n+\n+async function saveSession() {\n+    if (!fileSections) return;\n+    try {\n+        const db = await openDB();\n+        const tx = db.transaction(storeName, \"readwrite\");\n+        const store = tx.objectStore(storeName);\n+        await store.put({ id: \"current\", file1: file1Data, file2: file2Data, sections: fileSections });\n+    } catch(e) {\n+        console.error(\"Failed to save session\", e);\n+    }\n+}\n+\n+async function loadSession() {\n+    try {\n+        const db = await openDB();\n+        return new Promise((resolve) => {\n+            const tx = db.transaction(storeName, \"readonly\");\n+            const store = tx.objectStore(storeName);\n+            const request = store.get(\"current\");\n+            request.onsuccess = (event) => {\n+                const data = event.target.result;\n+                if (data) {\n+                    file1Data = data.file1;\n+                    file2Data = data.file2;\n+                    fileSections = data.sections;\n+                    resolve(true);\n+                } else {\n+                    resolve(false);\n+                }\n+            };\n+            request.onerror = () => resolve(false);\n+        });\n+    } catch(e) {\n+        console.error(\"Failed to load session\", e);\n+        return false;\n+    }\n+}\n+\n+\n+function isIdenticalSubtitle(sub1, sub2) {\n+    if (!sub1 || !sub2) return false;\n+    return (sub1.start === sub2.start) && (sub1.end === sub2.end) && (sub1.content === sub2.content);\n+}\n+\n+function isIdenticalRow(arr1, arr2) {\n+    if (!arr1 || !arr2) return false;\n+    if (arr1.length !== arr2.length) return false;\n+    \n+    for (let i = 0; i < arr1.length; i++) {\n+        if (!isIdenticalSubtitle(arr1[i], arr2[i])) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+function isIdenticalTextRow(arr1, arr2) {\n+    if (!arr1 || !arr2) return false;\n+    if (arr1.length !== arr2.length) return false;\n+    \n+    for (let i = 0; i < arr1.length; i++) {\n+        if (arr1[i].content !== arr2[i].content) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+function compareSubtitles(srt1, srt2) {\n+    let i = 0; // iterator for srt1\n+    let j = 0; // iterator for srt2\n+    const sections = [];\n+    let index = 0;\n+    \n+    // Sort just in case? Usually valid SRT is sorted, but safe to assume it's okay or parser handles it.\n+    // server.js didn't sort input, so we assume valid input.\n+\n+    while (i < srt1.length || j < srt2.length) {\n+        const sectionFile1 = [];\n+        const sectionFile2 = [];\n+\n+        if (i >= srt1.length) {\n+            while (j < srt2.length) sectionFile2.push(srt2[j++]);\n+            sections.push({ index: index++, file1: null, file2: sectionFile2 });\n+            break;\n+        }\n+\n+        if (j >= srt2.length) {\n+            while (i < srt1.length) sectionFile1.push(srt1[i++]);\n+            sections.push({ index: index++, file1: sectionFile1, file2: null });\n+            break;\n+        }\n+\n+        const next_srt2_start = srt2[j].start;\n+        while (i < srt1.length && srt1[i].end <= next_srt2_start) {\n+            sectionFile1.push(srt1[i++]);\n+        }\n+\n+        if (!sectionFile1.length) {\n+            const next_srt1_start = srt1[i].start;\n+            while (j < srt2.length && srt2[j].end <= next_srt1_start) {\n+                sectionFile2.push(srt2[j++]);\n+            }    \n+        }\n+\n+        if (!sectionFile1.length && !sectionFile2.length) {\n+            while (i < srt1.length && j < srt2.length && isIdenticalSubtitle(srt1[i], srt2[j])) {\n+                sectionFile1.push(srt1[i++]);\n+                sectionFile2.push(srt2[j++]);\n+            }\n+        }\n+\n+        if (!sectionFile1.length && !sectionFile2.length) {\n+            let sectionEndTime = Math.max(srt1[i].end, srt2[j].end);\n+\n+            while (i < srt1.length && srt1[i].end <= sectionEndTime) {\n+                sectionFile1.push(srt1[i++]);\n+            }\n+    \n+            while (j < srt2.length && srt2[j].end <= sectionEndTime) {\n+                sectionFile2.push(srt2[j++]);\n+            }\n+        }\n+\n+        sections.push({ index: index++, file1: sectionFile1.length ? sectionFile1 : null, file2: sectionFile2.length ? sectionFile2 : null });\n+    }\n+\n+    return sections;\n+}\n+\n+function buildContent(captions) {\n+    let srt = '';\n+    var eol = \"\\r\\n\";\n+    for (var i = 0; i < captions.length; i++) {\n+        var caption = captions[i];\n+         srt += (i + 1).toString() + eol;\n+         srt += SrtParser.toTimeString(caption.start) + \" --> \" + SrtParser.toTimeString(caption.end) + eol;\n+         srt += caption.content + eol;\n+         srt += eol;\n+    }\n+    return srt;\n+}\n+\n+// Global functions for UI\n+\n+window.processFiles = async function(file1, file2) {\n+    if (!file1 || !file2) return;\n+    \n+    const read = (f) => new Promise(resolve => {\n+        const reader = new FileReader();\n+        reader.onload = (e) => resolve({ name: f.name, content: e.target.result });\n+        reader.readAsText(f);\n+    });\n+\n+    const [f1, f2] = await Promise.all([read(file1), read(file2)]);\n+    file1Data = f1;\n+    file2Data = f2;\n+\n+    const srt1 = SrtParser.parse(f1.content);\n+    const srt2 = SrtParser.parse(f2.content);\n+\n+    fileSections = compareSubtitles(srt1, srt2);\n+    saveSession();\n+    return fileSections;\n+}\n+\n+window.updateClientSubtitle = function(fileSide, index, newContent) {\n+    if (!fileSections) return;\n+    const section = fileSections.find(s => s.index === index);\n+    if (!section) return;\n+\n+    // The UI passes the raw text from the textarea. \n+    // We need to parse it back into the object structure.\n+    const parsed = SrtParser.parse(newContent);\n+    \n+    if (fileSide === 'file1') section.file1 = parsed;\n+    else section.file2 = parsed;\n+\n+    saveSession();\n+    return parsed;\n+}\n+\n+window.generateClientMergedFile = function(file1Indices, file2Indices) {\n+    if (!fileSections) return null;\n+    const selectedSubtitles = [];\n+\n+    fileSections.forEach(section => {\n+        if (file1Indices.includes(section.index) && section.file1) {\n+            section.file1.forEach(line => selectedSubtitles.push(line));\n+        }\n+        if (file2Indices.includes(section.index) && section.file2) {\n+            section.file2.forEach(line => selectedSubtitles.push(line));\n+        }\n+    });\n+\n+    // Sort by start time\n+    selectedSubtitles.sort((a, b) => a.start - b.start);\n+\n+    // Re-index? \n+    // The server `buildContent` uses loop index + 1. So yes, re-indexing happens automatically in buildContent.\n+    \n+    return buildContent(selectedSubtitles);\n+}\n+\n+// Auto-load on startup\n+window.addEventListener('load', async () => {\n+    if (await loadSession()) {\n+        console.log(\"Loaded session from IndexedDB\");\n+        if (typeof populateTable === 'function' && fileSections) {\n+             populateTable(fileSections);\n+        }\n+    }\n+});\n+\n+// UI Helper Functions and Event Handlers\n+\n+async function compareFiles() {\n+    const file1 = document.querySelector('input[name=\"file1\"]').files[0];\n+    const file2 = document.querySelector('input[name=\"file2\"]').files[0];\n+\n+    if (file1 && file2) {\n+        const sections = await window.processFiles(file1, file2);\n+        populateTable(sections);\n+    }\n+}\n+\n+function checkFilesSelected() {\n+    const file1 = document.querySelector('input[name=\"file1\"]').files[0];\n+    const file2 = document.querySelector('input[name=\"file2\"]').files[0];\n+\n+    if (file1 && file2) {\n+        compareFiles();\n+    }\n+}\n+\n+function formatTimestamp(milliseconds) {\n+    if (typeof milliseconds !== 'number') return milliseconds;\n+    \n+    const hours = Math.floor(milliseconds / 3600000);\n+    const minutes = Math.floor((milliseconds % 3600000) / 60000);\n+    const seconds = Math.floor((milliseconds % 60000) / 1000);\n+    const ms = milliseconds % 1000;\n+\n+    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;\n+}\n+\n+function replaceNewlinesWithBreaks(text) {\n+    return text.replace(/\\n/g, '<br/>');\n+}\n+\n+function generateSubtitleHTML(subtitles) {\n+    if (!subtitles || subtitles.length === 0) return '';\n+\n+    return subtitles.map(sub => `\n+        <div class='subtitle'>\n+            <b>${sub.index}. ${formatTimestamp(sub.start)} --> ${formatTimestamp(sub.end)}</b><br/>\n+            ${replaceNewlinesWithBreaks(sub.content)}\n+        </div>\n+    `).join('');\n+}\n+\n+function extractSubtitlesFromHtml(html) {\n+    const parser = new DOMParser();\n+    const doc = parser.parseFromString(html, 'text/html');\n+    const subtitles = doc.querySelectorAll('.subtitle');\n+\n+    return Array.from(subtitles).map((subtitle, n) => {\n+        const [header, ...textLines] = subtitle.innerHTML.split('<br>');\n+        header_text = header.replace(/<b>|<\\/b>/g, '').trim();","path":"public/js/app.js","commit_id":"8e98df7e41015b803cd6d19e0063cbda2a7981ca","original_commit_id":"8e98df7e41015b803cd6d19e0063cbda2a7981ca","user":{"login":"gemini-code-assist[bot]","id":176961590,"node_id":"BOT_kgDOCow4Ng","avatar_url":"https://avatars.githubusercontent.com/in/956858?v=4","gravatar_id":"","url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D","html_url":"https://github.com/apps/gemini-code-assist","followers_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/followers","following_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/repos","events_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"![high](https://www.gstatic.com/codereviewagent/high-priority.svg)\n\nThe variable `header_text` is assigned without being declared with `const`, `let`, or `var`. This creates an implicit global variable, which can lead to hard-to-track bugs and conflicts. This pattern of creating implicit globals is repeated throughout the file. Please declare all variables before use.\n\nOther occurrences:\n- `lines` in `generateSubtitleText` (line 324)\n- `lines` in `generateSubtitleContent` (line 332)\n- `text` in `makeEditable` (line 393)\n- `original` in `makeEditable` (line 394)\n\n```suggestion\n        const header_text = header.replace(/<b>|<\\/b>/g, '').trim();\n```","created_at":"2026-02-16T06:48:55Z","updated_at":"2026-02-16T06:48:55Z","html_url":"https://github.com/machinewrapped/srt-merger/pull/3#discussion_r2810915702","pull_request_url":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/3","_links":{"self":{"href":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/comments/2810915702"},"html":{"href":"https://github.com/machinewrapped/srt-merger/pull/3#discussion_r2810915702"},"pull_request":{"href":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/3"}},"reactions":{"url":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/comments/2810915702/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":292,"original_line":292,"side":"RIGHT","author_association":"NONE","original_position":292,"position":292,"subject_type":"line"},{"url":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/comments/2810915707","pull_request_review_id":3806929223,"id":2810915707,"node_id":"PRRC_kwDOK3wXas6niyt7","diff_hunk":"@@ -0,0 +1,524 @@\n+\n+let fileSections = null;\n+let file1Data = null; // { name, content }\n+let file2Data = null; // { name, content }\n+\n+// IndexedDB Setup\n+const dbName = \"SrtMergerDB\";\n+const storeName = \"session\";\n+\n+function openDB() {\n+    return new Promise((resolve, reject) => {\n+        const request = indexedDB.open(dbName, 1);\n+        request.onerror = (event) => reject(\"IndexedDB error: \" + event.target.error);\n+        request.onsuccess = (event) => resolve(event.target.result);\n+        request.onupgradeneeded = (event) => {\n+            const db = event.target.result;\n+            if (!db.objectStoreNames.contains(storeName)) {\n+                db.createObjectStore(storeName, { keyPath: \"id\" });\n+            }\n+        };\n+    });\n+}\n+\n+async function saveSession() {\n+    if (!fileSections) return;\n+    try {\n+        const db = await openDB();\n+        const tx = db.transaction(storeName, \"readwrite\");\n+        const store = tx.objectStore(storeName);\n+        await store.put({ id: \"current\", file1: file1Data, file2: file2Data, sections: fileSections });\n+    } catch(e) {\n+        console.error(\"Failed to save session\", e);\n+    }\n+}\n+\n+async function loadSession() {\n+    try {\n+        const db = await openDB();\n+        return new Promise((resolve) => {\n+            const tx = db.transaction(storeName, \"readonly\");\n+            const store = tx.objectStore(storeName);\n+            const request = store.get(\"current\");\n+            request.onsuccess = (event) => {\n+                const data = event.target.result;\n+                if (data) {\n+                    file1Data = data.file1;\n+                    file2Data = data.file2;\n+                    fileSections = data.sections;\n+                    resolve(true);\n+                } else {\n+                    resolve(false);\n+                }\n+            };\n+            request.onerror = () => resolve(false);\n+        });\n+    } catch(e) {\n+        console.error(\"Failed to load session\", e);\n+        return false;\n+    }\n+}\n+\n+\n+function isIdenticalSubtitle(sub1, sub2) {\n+    if (!sub1 || !sub2) return false;\n+    return (sub1.start === sub2.start) && (sub1.end === sub2.end) && (sub1.content === sub2.content);\n+}\n+\n+function isIdenticalRow(arr1, arr2) {\n+    if (!arr1 || !arr2) return false;\n+    if (arr1.length !== arr2.length) return false;\n+    \n+    for (let i = 0; i < arr1.length; i++) {\n+        if (!isIdenticalSubtitle(arr1[i], arr2[i])) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+function isIdenticalTextRow(arr1, arr2) {\n+    if (!arr1 || !arr2) return false;\n+    if (arr1.length !== arr2.length) return false;\n+    \n+    for (let i = 0; i < arr1.length; i++) {\n+        if (arr1[i].content !== arr2[i].content) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+function compareSubtitles(srt1, srt2) {\n+    let i = 0; // iterator for srt1\n+    let j = 0; // iterator for srt2\n+    const sections = [];\n+    let index = 0;\n+    \n+    // Sort just in case? Usually valid SRT is sorted, but safe to assume it's okay or parser handles it.\n+    // server.js didn't sort input, so we assume valid input.\n+\n+    while (i < srt1.length || j < srt2.length) {\n+        const sectionFile1 = [];\n+        const sectionFile2 = [];\n+\n+        if (i >= srt1.length) {\n+            while (j < srt2.length) sectionFile2.push(srt2[j++]);\n+            sections.push({ index: index++, file1: null, file2: sectionFile2 });\n+            break;\n+        }\n+\n+        if (j >= srt2.length) {\n+            while (i < srt1.length) sectionFile1.push(srt1[i++]);\n+            sections.push({ index: index++, file1: sectionFile1, file2: null });\n+            break;\n+        }\n+\n+        const next_srt2_start = srt2[j].start;\n+        while (i < srt1.length && srt1[i].end <= next_srt2_start) {\n+            sectionFile1.push(srt1[i++]);\n+        }\n+\n+        if (!sectionFile1.length) {\n+            const next_srt1_start = srt1[i].start;\n+            while (j < srt2.length && srt2[j].end <= next_srt1_start) {\n+                sectionFile2.push(srt2[j++]);\n+            }    \n+        }\n+\n+        if (!sectionFile1.length && !sectionFile2.length) {\n+            while (i < srt1.length && j < srt2.length && isIdenticalSubtitle(srt1[i], srt2[j])) {\n+                sectionFile1.push(srt1[i++]);\n+                sectionFile2.push(srt2[j++]);\n+            }\n+        }\n+\n+        if (!sectionFile1.length && !sectionFile2.length) {\n+            let sectionEndTime = Math.max(srt1[i].end, srt2[j].end);\n+\n+            while (i < srt1.length && srt1[i].end <= sectionEndTime) {\n+                sectionFile1.push(srt1[i++]);\n+            }\n+    \n+            while (j < srt2.length && srt2[j].end <= sectionEndTime) {\n+                sectionFile2.push(srt2[j++]);\n+            }\n+        }\n+\n+        sections.push({ index: index++, file1: sectionFile1.length ? sectionFile1 : null, file2: sectionFile2.length ? sectionFile2 : null });\n+    }\n+\n+    return sections;\n+}\n+\n+function buildContent(captions) {\n+    let srt = '';\n+    var eol = \"\\r\\n\";\n+    for (var i = 0; i < captions.length; i++) {\n+        var caption = captions[i];\n+         srt += (i + 1).toString() + eol;\n+         srt += SrtParser.toTimeString(caption.start) + \" --> \" + SrtParser.toTimeString(caption.end) + eol;\n+         srt += caption.content + eol;\n+         srt += eol;\n+    }\n+    return srt;\n+}\n+\n+// Global functions for UI\n+\n+window.processFiles = async function(file1, file2) {\n+    if (!file1 || !file2) return;\n+    \n+    const read = (f) => new Promise(resolve => {\n+        const reader = new FileReader();\n+        reader.onload = (e) => resolve({ name: f.name, content: e.target.result });\n+        reader.readAsText(f);\n+    });\n+\n+    const [f1, f2] = await Promise.all([read(file1), read(file2)]);\n+    file1Data = f1;\n+    file2Data = f2;\n+\n+    const srt1 = SrtParser.parse(f1.content);\n+    const srt2 = SrtParser.parse(f2.content);\n+\n+    fileSections = compareSubtitles(srt1, srt2);\n+    saveSession();\n+    return fileSections;\n+}\n+\n+window.updateClientSubtitle = function(fileSide, index, newContent) {\n+    if (!fileSections) return;\n+    const section = fileSections.find(s => s.index === index);\n+    if (!section) return;\n+\n+    // The UI passes the raw text from the textarea. \n+    // We need to parse it back into the object structure.\n+    const parsed = SrtParser.parse(newContent);\n+    \n+    if (fileSide === 'file1') section.file1 = parsed;\n+    else section.file2 = parsed;\n+\n+    saveSession();\n+    return parsed;\n+}\n+\n+window.generateClientMergedFile = function(file1Indices, file2Indices) {\n+    if (!fileSections) return null;\n+    const selectedSubtitles = [];\n+\n+    fileSections.forEach(section => {\n+        if (file1Indices.includes(section.index) && section.file1) {\n+            section.file1.forEach(line => selectedSubtitles.push(line));\n+        }\n+        if (file2Indices.includes(section.index) && section.file2) {\n+            section.file2.forEach(line => selectedSubtitles.push(line));\n+        }\n+    });\n+\n+    // Sort by start time\n+    selectedSubtitles.sort((a, b) => a.start - b.start);\n+\n+    // Re-index? \n+    // The server `buildContent` uses loop index + 1. So yes, re-indexing happens automatically in buildContent.\n+    \n+    return buildContent(selectedSubtitles);\n+}\n+\n+// Auto-load on startup\n+window.addEventListener('load', async () => {\n+    if (await loadSession()) {\n+        console.log(\"Loaded session from IndexedDB\");\n+        if (typeof populateTable === 'function' && fileSections) {\n+             populateTable(fileSections);\n+        }\n+    }\n+});\n+\n+// UI Helper Functions and Event Handlers\n+\n+async function compareFiles() {\n+    const file1 = document.querySelector('input[name=\"file1\"]').files[0];\n+    const file2 = document.querySelector('input[name=\"file2\"]').files[0];\n+\n+    if (file1 && file2) {\n+        const sections = await window.processFiles(file1, file2);\n+        populateTable(sections);\n+    }\n+}\n+\n+function checkFilesSelected() {\n+    const file1 = document.querySelector('input[name=\"file1\"]').files[0];\n+    const file2 = document.querySelector('input[name=\"file2\"]').files[0];\n+\n+    if (file1 && file2) {\n+        compareFiles();\n+    }\n+}\n+\n+function formatTimestamp(milliseconds) {\n+    if (typeof milliseconds !== 'number') return milliseconds;\n+    \n+    const hours = Math.floor(milliseconds / 3600000);\n+    const minutes = Math.floor((milliseconds % 3600000) / 60000);\n+    const seconds = Math.floor((milliseconds % 60000) / 1000);\n+    const ms = milliseconds % 1000;\n+\n+    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;\n+}\n+\n+function replaceNewlinesWithBreaks(text) {\n+    return text.replace(/\\n/g, '<br/>');\n+}\n+\n+function generateSubtitleHTML(subtitles) {\n+    if (!subtitles || subtitles.length === 0) return '';\n+\n+    return subtitles.map(sub => `\n+        <div class='subtitle'>\n+            <b>${sub.index}. ${formatTimestamp(sub.start)} --> ${formatTimestamp(sub.end)}</b><br/>\n+            ${replaceNewlinesWithBreaks(sub.content)}\n+        </div>\n+    `).join('');\n+}\n+\n+function extractSubtitlesFromHtml(html) {\n+    const parser = new DOMParser();\n+    const doc = parser.parseFromString(html, 'text/html');\n+    const subtitles = doc.querySelectorAll('.subtitle');\n+\n+    return Array.from(subtitles).map((subtitle, n) => {\n+        const [header, ...textLines] = subtitle.innerHTML.split('<br>');\n+        header_text = header.replace(/<b>|<\\/b>/g, '').trim();\n+        const [index, timestamps] = header_text.split('. ');\n+        const [start, end] = timestamps.match(/\\d{2}:\\d{2}:\\d{2},\\d{3}/g);\n+\n+        return {\n+            index: parseInt(index.trim(), 10),\n+            start: start,\n+            end: end,\n+            content: textLines.join('')\n+        };\n+    });\n+}\n+\n+function extractSubtitlesFromText(text) {\n+    const lines = text.split('\\n\\n');\n+    return lines.map((line, n) => {\n+        const [header, ...textLines] = line.split('\\n');\n+        const [index, timestamps] = header.split('. ');\n+        const [start, end] = timestamps.split(' --> ');\n+\n+        return {\n+            index: parseInt(index.trim(), 10),\n+            start: start,\n+            end: end,\n+            content: textLines.join('\\n')\n+        };\n+    });\n+}\n+\n+function generateSubtitleText(subtitles) {\n+    if (!subtitles || subtitles.length === 0) return '';\n+\n+    lines = subtitles.map(sub => `${sub.index}\\n${sub.start} --> ${sub.end}\\n${sub.content.trim()}`)\n+    \n+    return lines.join('\\n\\n');\n+}\n+\n+function generateSubtitleContent(subtitles) {\n+    if (!subtitles || subtitles.length === 0) return '';\n+\n+    lines = subtitles.map(sub => `${sub.index}\\n${sub.start} --> ${sub.end}\\n${sub.content.trim()}`)\n+    \n+    return lines.join('\\n\\n');\n+}\n+\n+\n+function createBootstrapCheckbox(name, value, isChecked = false, isHidden = false) {\n+    const checkboxWrapper = document.createElement('div');\n+    checkboxWrapper.classList.add('form-check');\n+\n+    const checkbox = document.createElement('input');\n+    checkbox.type = 'checkbox';\n+    checkbox.name = name;\n+    checkbox.value = value;\n+    checkbox.checked = isChecked;\n+    checkbox.classList.add('form-check-input');\n+    if (isHidden) checkbox.style.display = 'none';\n+\n+    checkbox.addEventListener('click', handleCheckboxClick);\n+\n+    checkboxWrapper.appendChild(checkbox);\n+\n+    return checkboxWrapper;\n+}\n+\n+function handleCheckboxClick(event) {\n+    const currentCheckbox = event.target;\n+    if (!event.shiftKey) {\n+        // Retrieve all checkboxes once to improve performance\n+        const siblingCheckboxes = document.querySelectorAll(\"input[type='checkbox']\");\n+        // Loop through checkboxes and deselect matching conditions\n+        siblingCheckboxes.forEach(checkbox => {\n+            if (checkbox !== currentCheckbox && checkbox.value === currentCheckbox.value) {\n+                checkbox.checked = false;\n+            }\n+        });\n+    }\n+}\n+\n+function autoResizeTextArea(textArea) {\n+    textArea.style.height = 'auto';\n+    console.log('Scroll height:', textArea.scrollHeight);\n+    textArea.style.height = textArea.scrollHeight + 'px';\n+}\n+\n+function makeEditable(cell, index, fileSide) {\n+    cell.ondblclick = () => {\n+        // Extract the content of the <div> with class 'subtitle' for the editable content\n+        const subtitles = extractSubtitlesFromHtml(cell.innerHTML);\n+        if (!subtitles) {\n+            console.error('Subtitle not found in cell:', cell);\n+            return;\n+        }\n+\n+        if (cell.querySelector('textarea')) {\n+            return;\n+        }\n+\n+        cell.dataset.file = fileSide;\n+        cell.dataset.index = index;\n+\n+        text = generateSubtitleText(subtitles)\n+        original = cell.innerHTML;\n+\n+        const input = document.createElement('textarea');\n+        input.value = text;\n+        input.classList.add('form-control');\n+        cell.innerHTML = '';\n+        cell.appendChild(input);\n+        autoResizeTextArea(input);\n+        input.addEventListener('input', () => autoResizeTextArea(input));\n+        input.focus();\n+\n+        input.onblur = () => {\n+            cell.innerHTML = original;\n+            updateSubtitlesLocally(fileSide, index, input.value);\n+        };\n+    };\n+}\n+\n+function populateTable(results) {\n+    const tableBody = document.getElementById('comparisonTable').querySelector('tbody');\n+    tableBody.innerHTML = ''; // Clear existing rows\n+\n+    results.forEach((result, index) => {\n+        const row = tableBody.insertRow();\n+        row.dataset.index = index;\n+\n+        // File 1 column\n+        const cell1 = row.insertCell();\n+        cell1.innerHTML = generateSubtitleHTML(result.file1);\n+        cell1.classList.add('file-column', 'file1');\n+        makeEditable(cell1, index, 'file1')\n+\n+        // Checkbox for File 1\n+        const cellCheckbox1 = row.insertCell();\n+        const checkbox1 = createBootstrapCheckbox('file1', result.index, !!result.file1, !result.file1);\n+        cellCheckbox1.appendChild(checkbox1);\n+\n+        // Checkbox for File 2\n+        const cellCheckbox2 = row.insertCell();\n+        const checkbox2 = createBootstrapCheckbox('file2', result.index, false, !result.file2);\n+        cellCheckbox2.appendChild(checkbox2);\n+\n+        // File 2 column\n+        const cell2 = row.insertCell();\n+        cell2.innerHTML = generateSubtitleHTML(result.file2);\n+        cell2.classList.add('file-column');\n+        makeEditable(cell2, index, 'file2')\n+\n+        if (isIdenticalRow(result.file1, result.file2)) {\n+            checkbox2.style.display = 'none';\n+            cell2.style.color = 'lightgrey';\n+        } else if (isIdenticalTextRow(result.file1, result.file2)) {\n+            cell2.style.color = 'grey';\n+        }\n+    });\n+}\n+\n+function updateCellContent(file, index, subtitles) {\n+    if (!subtitles) return;\n+\n+    const rows = document.querySelectorAll('tr');\n+    const row = Array.from(rows).find(row => row.dataset.index == index);\n+    console.assert(row, 'Row not found:', index);\n+\n+    const cells = row.querySelectorAll('td');\n+    const cell = Array.from(cells).find(cell => cell.dataset.file === file);\n+    console.assert(cell, 'Cell not found:', file, index);\n+\n+    cell.innerHTML = generateSubtitleHTML(subtitles);\n+}\n+\n+function updateSubtitlesLocally(file, index, content) {\n+    const updatedSubtitles = window.updateClientSubtitle(file, index, content);\n+    console.log('Subtitle updated locally', updatedSubtitles);\n+    updateCellContent(file, index, updatedSubtitles);\n+}\n+\n+async function saveMergedFile() {\n+    const selectedFile1Indices = [...document.querySelectorAll('input[name=\"file1\"]:checked')].map(checkbox => parseInt(checkbox.value, 10));\n+    const selectedFile2Indices = [...document.querySelectorAll('input[name=\"file2\"]:checked')].map(checkbox => parseInt(checkbox.value, 10));\n+\n+    const mergedContent = window.generateClientMergedFile(selectedFile1Indices, selectedFile2Indices);\n+    \n+    // Try the File System Access API first (supported in Edge, Chrome, Opera)\n+    if (window.showSaveFilePicker) {\n+        try {\n+            const handle = await window.showSaveFilePicker({\n+                suggestedName: 'merged.srt',\n+                types: [{\n+                    description: 'SubRip Subtitle File',\n+                    accept: { 'text/plain': ['.srt'] },\n+                }],\n+            });\n+            const writable = await handle.createWritable();\n+            await writable.write(mergedContent);\n+            await writable.close();\n+            return;\n+        } catch (err) {\n+            if (err.name !== 'AbortError') {\n+                console.error('Failed to save file:', err);\n+                alert('Failed to save file using the system dialog. Falling back to default download.');\n+            } else {\n+                return; // User cancelled\n+            }\n+        }\n+    }\n+\n+    // Fallback for other browsers or if API fails\n+    const blob = new Blob([mergedContent], { type: 'text/plain' });\n+    const url = URL.createObjectURL(blob);\n+    const a = document.createElement('a');\n+    a.style.display = 'none';\n+    a.href = url;\n+    a.download = 'merged.srt';\n+    document.body.appendChild(a);\n+    a.click();\n+    \n+    // Slight delay before cleanup to ensure the download starts properly\n+    setTimeout(() => {\n+        document.body.removeChild(a);\n+        URL.revokeObjectURL(url);\n+    }, 100);\n+}\n+\n+async function resetSession() {\n+    if (confirm(\"Are you sure you want to reset? This will clear all loaded files and changes.\")) {\n+        const dbs = await window.indexedDB.databases();\n+        dbs.forEach(db => window.indexedDB.deleteDatabase(db.name));\n+        location.reload();\n+    }\n+}","path":"public/js/app.js","commit_id":"8e98df7e41015b803cd6d19e0063cbda2a7981ca","original_commit_id":"8e98df7e41015b803cd6d19e0063cbda2a7981ca","user":{"login":"gemini-code-assist[bot]","id":176961590,"node_id":"BOT_kgDOCow4Ng","avatar_url":"https://avatars.githubusercontent.com/in/956858?v=4","gravatar_id":"","url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D","html_url":"https://github.com/apps/gemini-code-assist","followers_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/followers","following_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/repos","events_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"![high](https://www.gstatic.com/codereviewagent/high-priority.svg)\n\nThe `resetSession` function uses `window.indexedDB.databases()`, which is a non-standard and deprecated API. It is not supported in Firefox or Safari, which will prevent the reset functionality from working for users on those browsers.\n\nA more robust and standard way to clear the data is to delete the specific database by name using `window.indexedDB.deleteDatabase(dbName)`. This also allows for proper handling of success, error, and blocked events.\n\n```suggestion\nasync function resetSession() {\n    if (confirm(\"Are you sure you want to reset? This will clear all loaded files and changes.\")) {\n        const dbName = \"SrtMergerDB\";\n        const deleteRequest = window.indexedDB.deleteDatabase(dbName);\n\n        deleteRequest.onsuccess = () => {\n            console.log(\"Database deleted successfully.\");\n            location.reload();\n        };\n        deleteRequest.onerror = () => {\n            console.error(\"Error deleting database.\");\n            alert(\"Could not reset session. Please try again.\");\n        };\n        deleteRequest.onblocked = () => {\n            console.warn(\"Database delete blocked.\");\n            alert(\"Reset is blocked. Please close any other tabs with this application open and try again.\");\n        };\n    }\n}\n```","created_at":"2026-02-16T06:48:55Z","updated_at":"2026-02-16T06:48:55Z","html_url":"https://github.com/machinewrapped/srt-merger/pull/3#discussion_r2810915707","pull_request_url":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/3","_links":{"self":{"href":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/comments/2810915707"},"html":{"href":"https://github.com/machinewrapped/srt-merger/pull/3#discussion_r2810915707"},"pull_request":{"href":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/3"}},"reactions":{"url":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/comments/2810915707/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":518,"original_start_line":518,"start_side":"RIGHT","line":524,"original_line":524,"side":"RIGHT","author_association":"NONE","original_position":524,"position":524,"subject_type":"line"},{"url":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/comments/2810915711","pull_request_review_id":3806929223,"id":2810915711,"node_id":"PRRC_kwDOK3wXas6niyt_","diff_hunk":"@@ -0,0 +1,524 @@\n+\n+let fileSections = null;\n+let file1Data = null; // { name, content }\n+let file2Data = null; // { name, content }\n+\n+// IndexedDB Setup\n+const dbName = \"SrtMergerDB\";\n+const storeName = \"session\";\n+\n+function openDB() {\n+    return new Promise((resolve, reject) => {\n+        const request = indexedDB.open(dbName, 1);\n+        request.onerror = (event) => reject(\"IndexedDB error: \" + event.target.error);\n+        request.onsuccess = (event) => resolve(event.target.result);\n+        request.onupgradeneeded = (event) => {\n+            const db = event.target.result;\n+            if (!db.objectStoreNames.contains(storeName)) {\n+                db.createObjectStore(storeName, { keyPath: \"id\" });\n+            }\n+        };\n+    });\n+}\n+\n+async function saveSession() {\n+    if (!fileSections) return;\n+    try {\n+        const db = await openDB();\n+        const tx = db.transaction(storeName, \"readwrite\");\n+        const store = tx.objectStore(storeName);\n+        await store.put({ id: \"current\", file1: file1Data, file2: file2Data, sections: fileSections });\n+    } catch(e) {\n+        console.error(\"Failed to save session\", e);\n+    }\n+}\n+\n+async function loadSession() {\n+    try {\n+        const db = await openDB();\n+        return new Promise((resolve) => {\n+            const tx = db.transaction(storeName, \"readonly\");\n+            const store = tx.objectStore(storeName);\n+            const request = store.get(\"current\");\n+            request.onsuccess = (event) => {\n+                const data = event.target.result;\n+                if (data) {\n+                    file1Data = data.file1;\n+                    file2Data = data.file2;\n+                    fileSections = data.sections;\n+                    resolve(true);\n+                } else {\n+                    resolve(false);\n+                }\n+            };\n+            request.onerror = () => resolve(false);\n+        });\n+    } catch(e) {\n+        console.error(\"Failed to load session\", e);\n+        return false;\n+    }\n+}\n+\n+\n+function isIdenticalSubtitle(sub1, sub2) {\n+    if (!sub1 || !sub2) return false;\n+    return (sub1.start === sub2.start) && (sub1.end === sub2.end) && (sub1.content === sub2.content);\n+}\n+\n+function isIdenticalRow(arr1, arr2) {\n+    if (!arr1 || !arr2) return false;\n+    if (arr1.length !== arr2.length) return false;\n+    \n+    for (let i = 0; i < arr1.length; i++) {\n+        if (!isIdenticalSubtitle(arr1[i], arr2[i])) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+function isIdenticalTextRow(arr1, arr2) {\n+    if (!arr1 || !arr2) return false;\n+    if (arr1.length !== arr2.length) return false;\n+    \n+    for (let i = 0; i < arr1.length; i++) {\n+        if (arr1[i].content !== arr2[i].content) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+function compareSubtitles(srt1, srt2) {\n+    let i = 0; // iterator for srt1\n+    let j = 0; // iterator for srt2\n+    const sections = [];\n+    let index = 0;\n+    \n+    // Sort just in case? Usually valid SRT is sorted, but safe to assume it's okay or parser handles it.\n+    // server.js didn't sort input, so we assume valid input.\n+\n+    while (i < srt1.length || j < srt2.length) {\n+        const sectionFile1 = [];\n+        const sectionFile2 = [];\n+\n+        if (i >= srt1.length) {\n+            while (j < srt2.length) sectionFile2.push(srt2[j++]);\n+            sections.push({ index: index++, file1: null, file2: sectionFile2 });\n+            break;\n+        }\n+\n+        if (j >= srt2.length) {\n+            while (i < srt1.length) sectionFile1.push(srt1[i++]);\n+            sections.push({ index: index++, file1: sectionFile1, file2: null });\n+            break;\n+        }\n+\n+        const next_srt2_start = srt2[j].start;\n+        while (i < srt1.length && srt1[i].end <= next_srt2_start) {\n+            sectionFile1.push(srt1[i++]);\n+        }\n+\n+        if (!sectionFile1.length) {\n+            const next_srt1_start = srt1[i].start;\n+            while (j < srt2.length && srt2[j].end <= next_srt1_start) {\n+                sectionFile2.push(srt2[j++]);\n+            }    \n+        }\n+\n+        if (!sectionFile1.length && !sectionFile2.length) {\n+            while (i < srt1.length && j < srt2.length && isIdenticalSubtitle(srt1[i], srt2[j])) {\n+                sectionFile1.push(srt1[i++]);\n+                sectionFile2.push(srt2[j++]);\n+            }\n+        }\n+\n+        if (!sectionFile1.length && !sectionFile2.length) {\n+            let sectionEndTime = Math.max(srt1[i].end, srt2[j].end);\n+\n+            while (i < srt1.length && srt1[i].end <= sectionEndTime) {\n+                sectionFile1.push(srt1[i++]);\n+            }\n+    \n+            while (j < srt2.length && srt2[j].end <= sectionEndTime) {\n+                sectionFile2.push(srt2[j++]);\n+            }\n+        }\n+\n+        sections.push({ index: index++, file1: sectionFile1.length ? sectionFile1 : null, file2: sectionFile2.length ? sectionFile2 : null });\n+    }\n+\n+    return sections;\n+}\n+\n+function buildContent(captions) {\n+    let srt = '';\n+    var eol = \"\\r\\n\";\n+    for (var i = 0; i < captions.length; i++) {\n+        var caption = captions[i];","path":"public/js/app.js","commit_id":"8e98df7e41015b803cd6d19e0063cbda2a7981ca","original_commit_id":"8e98df7e41015b803cd6d19e0063cbda2a7981ca","user":{"login":"gemini-code-assist[bot]","id":176961590,"node_id":"BOT_kgDOCow4Ng","avatar_url":"https://avatars.githubusercontent.com/in/956858?v=4","gravatar_id":"","url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D","html_url":"https://github.com/apps/gemini-code-assist","followers_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/followers","following_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/repos","events_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)\n\nThe `buildContent` function uses `var` for variable declarations. It's modern JavaScript best practice to use `let` or `const` instead of `var` to avoid issues with function-level scoping and hoisting. `const` should be preferred for variables that are not reassigned.\n\n```suggestion\n    const eol = \"\\r\\n\";\n    for (let i = 0; i < captions.length; i++) {\n        const caption = captions[i];\n```","created_at":"2026-02-16T06:48:55Z","updated_at":"2026-02-16T06:48:55Z","html_url":"https://github.com/machinewrapped/srt-merger/pull/3#discussion_r2810915711","pull_request_url":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/3","_links":{"self":{"href":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/comments/2810915711"},"html":{"href":"https://github.com/machinewrapped/srt-merger/pull/3#discussion_r2810915711"},"pull_request":{"href":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/3"}},"reactions":{"url":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/comments/2810915711/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":156,"original_start_line":156,"start_side":"RIGHT","line":158,"original_line":158,"side":"RIGHT","author_association":"NONE","original_position":158,"position":158,"subject_type":"line"},{"url":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/comments/2810915717","pull_request_review_id":3806929223,"id":2810915717,"node_id":"PRRC_kwDOK3wXas6niyuF","diff_hunk":"@@ -0,0 +1,524 @@\n+\n+let fileSections = null;\n+let file1Data = null; // { name, content }\n+let file2Data = null; // { name, content }\n+\n+// IndexedDB Setup\n+const dbName = \"SrtMergerDB\";\n+const storeName = \"session\";\n+\n+function openDB() {\n+    return new Promise((resolve, reject) => {\n+        const request = indexedDB.open(dbName, 1);\n+        request.onerror = (event) => reject(\"IndexedDB error: \" + event.target.error);\n+        request.onsuccess = (event) => resolve(event.target.result);\n+        request.onupgradeneeded = (event) => {\n+            const db = event.target.result;\n+            if (!db.objectStoreNames.contains(storeName)) {\n+                db.createObjectStore(storeName, { keyPath: \"id\" });\n+            }\n+        };\n+    });\n+}\n+\n+async function saveSession() {\n+    if (!fileSections) return;\n+    try {\n+        const db = await openDB();\n+        const tx = db.transaction(storeName, \"readwrite\");\n+        const store = tx.objectStore(storeName);\n+        await store.put({ id: \"current\", file1: file1Data, file2: file2Data, sections: fileSections });\n+    } catch(e) {\n+        console.error(\"Failed to save session\", e);\n+    }\n+}\n+\n+async function loadSession() {\n+    try {\n+        const db = await openDB();\n+        return new Promise((resolve) => {\n+            const tx = db.transaction(storeName, \"readonly\");\n+            const store = tx.objectStore(storeName);\n+            const request = store.get(\"current\");\n+            request.onsuccess = (event) => {\n+                const data = event.target.result;\n+                if (data) {\n+                    file1Data = data.file1;\n+                    file2Data = data.file2;\n+                    fileSections = data.sections;\n+                    resolve(true);\n+                } else {\n+                    resolve(false);\n+                }\n+            };\n+            request.onerror = () => resolve(false);\n+        });\n+    } catch(e) {\n+        console.error(\"Failed to load session\", e);\n+        return false;\n+    }\n+}\n+\n+\n+function isIdenticalSubtitle(sub1, sub2) {\n+    if (!sub1 || !sub2) return false;\n+    return (sub1.start === sub2.start) && (sub1.end === sub2.end) && (sub1.content === sub2.content);\n+}\n+\n+function isIdenticalRow(arr1, arr2) {\n+    if (!arr1 || !arr2) return false;\n+    if (arr1.length !== arr2.length) return false;\n+    \n+    for (let i = 0; i < arr1.length; i++) {\n+        if (!isIdenticalSubtitle(arr1[i], arr2[i])) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+function isIdenticalTextRow(arr1, arr2) {\n+    if (!arr1 || !arr2) return false;\n+    if (arr1.length !== arr2.length) return false;\n+    \n+    for (let i = 0; i < arr1.length; i++) {\n+        if (arr1[i].content !== arr2[i].content) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+function compareSubtitles(srt1, srt2) {\n+    let i = 0; // iterator for srt1\n+    let j = 0; // iterator for srt2\n+    const sections = [];\n+    let index = 0;\n+    \n+    // Sort just in case? Usually valid SRT is sorted, but safe to assume it's okay or parser handles it.\n+    // server.js didn't sort input, so we assume valid input.\n+\n+    while (i < srt1.length || j < srt2.length) {\n+        const sectionFile1 = [];\n+        const sectionFile2 = [];\n+\n+        if (i >= srt1.length) {\n+            while (j < srt2.length) sectionFile2.push(srt2[j++]);\n+            sections.push({ index: index++, file1: null, file2: sectionFile2 });\n+            break;\n+        }\n+\n+        if (j >= srt2.length) {\n+            while (i < srt1.length) sectionFile1.push(srt1[i++]);\n+            sections.push({ index: index++, file1: sectionFile1, file2: null });\n+            break;\n+        }\n+\n+        const next_srt2_start = srt2[j].start;\n+        while (i < srt1.length && srt1[i].end <= next_srt2_start) {\n+            sectionFile1.push(srt1[i++]);\n+        }\n+\n+        if (!sectionFile1.length) {\n+            const next_srt1_start = srt1[i].start;\n+            while (j < srt2.length && srt2[j].end <= next_srt1_start) {\n+                sectionFile2.push(srt2[j++]);\n+            }    \n+        }\n+\n+        if (!sectionFile1.length && !sectionFile2.length) {\n+            while (i < srt1.length && j < srt2.length && isIdenticalSubtitle(srt1[i], srt2[j])) {\n+                sectionFile1.push(srt1[i++]);\n+                sectionFile2.push(srt2[j++]);\n+            }\n+        }\n+\n+        if (!sectionFile1.length && !sectionFile2.length) {\n+            let sectionEndTime = Math.max(srt1[i].end, srt2[j].end);\n+\n+            while (i < srt1.length && srt1[i].end <= sectionEndTime) {\n+                sectionFile1.push(srt1[i++]);\n+            }\n+    \n+            while (j < srt2.length && srt2[j].end <= sectionEndTime) {\n+                sectionFile2.push(srt2[j++]);\n+            }\n+        }\n+\n+        sections.push({ index: index++, file1: sectionFile1.length ? sectionFile1 : null, file2: sectionFile2.length ? sectionFile2 : null });\n+    }\n+\n+    return sections;\n+}\n+\n+function buildContent(captions) {\n+    let srt = '';\n+    var eol = \"\\r\\n\";\n+    for (var i = 0; i < captions.length; i++) {\n+        var caption = captions[i];\n+         srt += (i + 1).toString() + eol;\n+         srt += SrtParser.toTimeString(caption.start) + \" --> \" + SrtParser.toTimeString(caption.end) + eol;\n+         srt += caption.content + eol;\n+         srt += eol;\n+    }\n+    return srt;\n+}\n+\n+// Global functions for UI\n+\n+window.processFiles = async function(file1, file2) {\n+    if (!file1 || !file2) return;\n+    \n+    const read = (f) => new Promise(resolve => {\n+        const reader = new FileReader();\n+        reader.onload = (e) => resolve({ name: f.name, content: e.target.result });\n+        reader.readAsText(f);\n+    });\n+\n+    const [f1, f2] = await Promise.all([read(file1), read(file2)]);\n+    file1Data = f1;\n+    file2Data = f2;\n+\n+    const srt1 = SrtParser.parse(f1.content);\n+    const srt2 = SrtParser.parse(f2.content);\n+\n+    fileSections = compareSubtitles(srt1, srt2);\n+    saveSession();\n+    return fileSections;\n+}\n+\n+window.updateClientSubtitle = function(fileSide, index, newContent) {\n+    if (!fileSections) return;\n+    const section = fileSections.find(s => s.index === index);\n+    if (!section) return;\n+\n+    // The UI passes the raw text from the textarea. \n+    // We need to parse it back into the object structure.\n+    const parsed = SrtParser.parse(newContent);\n+    \n+    if (fileSide === 'file1') section.file1 = parsed;\n+    else section.file2 = parsed;\n+\n+    saveSession();\n+    return parsed;\n+}\n+\n+window.generateClientMergedFile = function(file1Indices, file2Indices) {\n+    if (!fileSections) return null;\n+    const selectedSubtitles = [];\n+\n+    fileSections.forEach(section => {\n+        if (file1Indices.includes(section.index) && section.file1) {\n+            section.file1.forEach(line => selectedSubtitles.push(line));\n+        }\n+        if (file2Indices.includes(section.index) && section.file2) {\n+            section.file2.forEach(line => selectedSubtitles.push(line));\n+        }\n+    });\n+\n+    // Sort by start time\n+    selectedSubtitles.sort((a, b) => a.start - b.start);\n+\n+    // Re-index? \n+    // The server `buildContent` uses loop index + 1. So yes, re-indexing happens automatically in buildContent.\n+    \n+    return buildContent(selectedSubtitles);\n+}\n+\n+// Auto-load on startup\n+window.addEventListener('load', async () => {\n+    if (await loadSession()) {\n+        console.log(\"Loaded session from IndexedDB\");\n+        if (typeof populateTable === 'function' && fileSections) {\n+             populateTable(fileSections);\n+        }\n+    }\n+});\n+\n+// UI Helper Functions and Event Handlers\n+\n+async function compareFiles() {\n+    const file1 = document.querySelector('input[name=\"file1\"]').files[0];\n+    const file2 = document.querySelector('input[name=\"file2\"]').files[0];\n+\n+    if (file1 && file2) {\n+        const sections = await window.processFiles(file1, file2);\n+        populateTable(sections);\n+    }\n+}\n+\n+function checkFilesSelected() {\n+    const file1 = document.querySelector('input[name=\"file1\"]').files[0];\n+    const file2 = document.querySelector('input[name=\"file2\"]').files[0];\n+\n+    if (file1 && file2) {\n+        compareFiles();\n+    }\n+}\n+\n+function formatTimestamp(milliseconds) {\n+    if (typeof milliseconds !== 'number') return milliseconds;\n+    \n+    const hours = Math.floor(milliseconds / 3600000);\n+    const minutes = Math.floor((milliseconds % 3600000) / 60000);\n+    const seconds = Math.floor((milliseconds % 60000) / 1000);\n+    const ms = milliseconds % 1000;\n+\n+    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;\n+}\n+\n+function replaceNewlinesWithBreaks(text) {\n+    return text.replace(/\\n/g, '<br/>');\n+}\n+\n+function generateSubtitleHTML(subtitles) {\n+    if (!subtitles || subtitles.length === 0) return '';\n+\n+    return subtitles.map(sub => `\n+        <div class='subtitle'>\n+            <b>${sub.index}. ${formatTimestamp(sub.start)} --> ${formatTimestamp(sub.end)}</b><br/>\n+            ${replaceNewlinesWithBreaks(sub.content)}\n+        </div>\n+    `).join('');\n+}\n+\n+function extractSubtitlesFromHtml(html) {\n+    const parser = new DOMParser();\n+    const doc = parser.parseFromString(html, 'text/html');\n+    const subtitles = doc.querySelectorAll('.subtitle');\n+\n+    return Array.from(subtitles).map((subtitle, n) => {\n+        const [header, ...textLines] = subtitle.innerHTML.split('<br>');\n+        header_text = header.replace(/<b>|<\\/b>/g, '').trim();\n+        const [index, timestamps] = header_text.split('. ');\n+        const [start, end] = timestamps.match(/\\d{2}:\\d{2}:\\d{2},\\d{3}/g);\n+\n+        return {\n+            index: parseInt(index.trim(), 10),\n+            start: start,\n+            end: end,\n+            content: textLines.join('')\n+        };\n+    });\n+}\n+\n+function extractSubtitlesFromText(text) {\n+    const lines = text.split('\\n\\n');\n+    return lines.map((line, n) => {\n+        const [header, ...textLines] = line.split('\\n');\n+        const [index, timestamps] = header.split('. ');\n+        const [start, end] = timestamps.split(' --> ');\n+\n+        return {\n+            index: parseInt(index.trim(), 10),\n+            start: start,\n+            end: end,\n+            content: textLines.join('\\n')\n+        };\n+    });\n+}\n+\n+function generateSubtitleText(subtitles) {\n+    if (!subtitles || subtitles.length === 0) return '';\n+\n+    lines = subtitles.map(sub => `${sub.index}\\n${sub.start} --> ${sub.end}\\n${sub.content.trim()}`)\n+    \n+    return lines.join('\\n\\n');\n+}\n+\n+function generateSubtitleContent(subtitles) {\n+    if (!subtitles || subtitles.length === 0) return '';\n+\n+    lines = subtitles.map(sub => `${sub.index}\\n${sub.start} --> ${sub.end}\\n${sub.content.trim()}`)\n+    \n+    return lines.join('\\n\\n');\n+}\n+\n+\n+function createBootstrapCheckbox(name, value, isChecked = false, isHidden = false) {\n+    const checkboxWrapper = document.createElement('div');\n+    checkboxWrapper.classList.add('form-check');\n+\n+    const checkbox = document.createElement('input');\n+    checkbox.type = 'checkbox';\n+    checkbox.name = name;\n+    checkbox.value = value;\n+    checkbox.checked = isChecked;\n+    checkbox.classList.add('form-check-input');\n+    if (isHidden) checkbox.style.display = 'none';\n+\n+    checkbox.addEventListener('click', handleCheckboxClick);\n+\n+    checkboxWrapper.appendChild(checkbox);\n+\n+    return checkboxWrapper;\n+}\n+\n+function handleCheckboxClick(event) {\n+    const currentCheckbox = event.target;\n+    if (!event.shiftKey) {\n+        // Retrieve all checkboxes once to improve performance\n+        const siblingCheckboxes = document.querySelectorAll(\"input[type='checkbox']\");\n+        // Loop through checkboxes and deselect matching conditions\n+        siblingCheckboxes.forEach(checkbox => {\n+            if (checkbox !== currentCheckbox && checkbox.value === currentCheckbox.value) {\n+                checkbox.checked = false;\n+            }\n+        });\n+    }\n+}\n+\n+function autoResizeTextArea(textArea) {\n+    textArea.style.height = 'auto';\n+    console.log('Scroll height:', textArea.scrollHeight);","path":"public/js/app.js","commit_id":"8e98df7e41015b803cd6d19e0063cbda2a7981ca","original_commit_id":"8e98df7e41015b803cd6d19e0063cbda2a7981ca","user":{"login":"gemini-code-assist[bot]","id":176961590,"node_id":"BOT_kgDOCow4Ng","avatar_url":"https://avatars.githubusercontent.com/in/956858?v=4","gravatar_id":"","url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D","html_url":"https://github.com/apps/gemini-code-assist","followers_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/followers","following_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/repos","events_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)\n\nThere is a `console.log` statement left in the code. While useful for debugging, it should be removed from the final code to avoid cluttering the browser console for end-users.","created_at":"2026-02-16T06:48:55Z","updated_at":"2026-02-16T06:48:55Z","html_url":"https://github.com/machinewrapped/srt-merger/pull/3#discussion_r2810915717","pull_request_url":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/3","_links":{"self":{"href":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/comments/2810915717"},"html":{"href":"https://github.com/machinewrapped/srt-merger/pull/3#discussion_r2810915717"},"pull_request":{"href":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/3"}},"reactions":{"url":"https://api.github.com/repos/machinewrapped/srt-merger/pulls/comments/2810915717/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":373,"original_line":373,"side":"RIGHT","author_association":"NONE","original_position":373,"position":373,"subject_type":"line"}]